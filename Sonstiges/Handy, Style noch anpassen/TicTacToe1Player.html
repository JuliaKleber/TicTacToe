<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Tic Tac Toe</title>
        <style>
            body{
                font-family: arial;
                font-size: 18px;
                background-color:#f7f6d6;
                margin: 0px;
            }

            header{
                background-image: linear-gradient(
                    to right,
                    #B5D5D8,
                    #fcb1f2,
                    #ffff00);
                padding: 10px;
                top: 0px;
                position: sticky;
                text-align: center;
                font-size: 35px;
            }

            #boardContainer{
                text-align: center;
                padding: 10px;
                margin: 10px;
            }

            canvas{
                width: 100px;
                height: 100px;
                padding: 0px 0px;
            }

            p{
                text-align: center;
            }

            #meldung{
                margin: 20px;
                text-align: center;
            }

            footer{
                background-image: linear-gradient(
                    to right,
                    #B5D5D8,
                    #fcb1f2,
                    #ffff00);
                position: sticky;
                bottom: 0px;
                padding: 5px;
                margin: 100px 0px 0px 0px;
                font-size: 15px;
                text-align: center;
            }
        </style>     
    </head>
    <body>
        <header>
            Tic Tac Toe
        </header>
        <main>
            <div id="outputStart">
                <p>Spieler 1 setzt Kreuze und Spieler 2 setzt Kreise.<br>
                Wer als erstes drei in einer Reihe hat gewinnt.<br>
                </p>
            </div>
            <div id="boardContainer"></div>
            <p id="outputEnd"></p>
        </main>
        <script>
            "use strict";

            // Wird benötigt um die Größen der Kacheln anzupassen.
            const widthTiles = 140;
            // Wird benötigt um die Größe der Symbole in den Kacheln anzupassen.
            const symbolPadding = 20;
            // Bestimmt wer am Zug ist.
            let isCircleTurn;
            // Speichert Informationen zum Zustand des Spielbretts.
            let board;
            // Wird für die Strategie der KI benötigt.
            let numberTurnKI;
            // Legt fest wer das Spiel beginnt.
            let startPlayerComputer;
            // Bestimmt die Zeitverzögerung der Computerspielzüge.
            const timeDelay = 350;

            class Board {
                // Erstellt eine Klasse für ein Spielbrett.
                // Es können Werte für die Felder gespeichert werden.
                // Die Werte sind null (kein Kreis und kein Kreuz),
                // 1 (Kreuz) und 0 (Kreis).
                // Außerdem wird gespeichert, wie viele Kreuze und Kreise
                // sich in den Reihen, Spalten und Diagonalen befinden. 
                constructor(fields) {
                    this.fields = fields;
                    this.row1 = { "cross": 0, "circle": 0 };
                    this.row2 = { "cross": 0, "circle": 0 };
                    this.row3 = { "cross": 0, "circle": 0 };
                    this.column1 = { "cross": 0, "circle": 0 };
                    this.column2 = { "cross": 0, "circle": 0 };
                    this.column3 = { "cross": 0, "circle": 0 };
                    this.diagonal1 = { "cross": 0, "circle": 0 };
                    this.diagonal2 = { "cross": 0, "circle": 0 };
                }
            }

            function initializeGamePart1() {
                // Bereitet das Spiel vor.

                // Wird für die Strategie der KI benötigt.
                numberTurnKI = 1;
                // Kreuz fängt an.
                isCircleTurn = false;
                // Initialisiert das Objekt board um die
                // Information über das Spielbrett zu speichern.
                board = createBoardInformation();
                // Fragt, welcher Spieler anfangen soll.
                selectStartingPlayer();
            }

            function initializeGamePart2() {
                // Bereitet das Spiel vor.

                // Erstellt die leeren Leinwände für das Spiel
                initializeGraphicalBoard();
                // Zeichnet die Kacheln.
                drawSquaresInitial();
                // Entweder startet der Computer
                // mit einer kleinen Zeitverzögerung
                // mit dem Setzen von Kreuzen 
                // oder der Spieler startet.
                if (startPlayerComputer == true) {
                    setTimeout(computerTurnCross, timeDelay);
                }
                else {
                    humanTurnOn();
                }
            }

            function initializeGraphicalBoard() {
                // Erstellt die Leinwände für das Spielbrett
                // über die Funktion createCanvas
                // und fügt sie boardContainer hinzu.
                const boardContainer = document.getElementById("boardContainer");
                document.getElementById("boardContainer").style.margin = "20px 20px 88px 20px";
                for (let i = 0; i < 9; i++) {
                    const canvas = createCanvas("myCanvas" + i);
                    boardContainer.appendChild(canvas);
                    if (i === 2 || i === 5) {
                        const lineBreak = document.createElement("br");
                        boardContainer.appendChild(lineBreak);
                        lineBreak.id = "br" + i
                    }
                }
            }

            function createCanvas(id) {
                // Erstellt Leinwände für das Spielbrett.
                const canvas = document.createElement("canvas");
                canvas.id = id;
                canvas.width = widthTiles;
                canvas.height = widthTiles;
                return canvas;
            }

            function drawSquaresInitial() {
                // Zeichnet am Anfang des Spiels 9 leere Kacheln.
                for (let i=0; i < 9; i++) {
                    const myCanvas = 'myCanvas' + i;
                    const canvas = document.getElementById(myCanvas);
                    const context = canvas.getContext('2d');
                    context.strokeWidth = 1;
                    context.fillStyle = "yellow";
                    context.strokeStyle = "schwarz";
                    context.fillRect(0, 0, widthTiles, widthTiles);
                    context.strokeRect(0, 0, widthTiles, widthTiles);
                }
            }

            function createBoardInformation() {
                // Erstellt ein Instanz des Objekts board um 
                // Informationen zum Spielbrett zu speichern.
                let emptyBoard = [];
                for (let i = 0; i < 9; i++) {
                    emptyBoard.push(null);
                }
                const board = new Board(emptyBoard);
            return board;
            }

            function selectStartingPlayer() {
                // Es wird ein Paragraph p erstellt mit der Frage wer das Spiel beginnen soll.
                // Außerdem werden drei Buttons, "Ich", "Computer" und "zufällig" erstellt.
                const outputStart = document.getElementById("outputStart");
                const questionStartPlayer = document.createElement("p");
                questionStartPlayer.id = "questionStartPlayer";
                outputStart.appendChild(questionStartPlayer);
                questionStartPlayer.innerHTML = "Wer soll anfangen?<br>";
                const buttonHuman = createButton("buttonHuman", "Ich");
                questionStartPlayer.appendChild(buttonHuman);
                const buttonComputer = createButton("buttonComputer", "Computer");
                questionStartPlayer.appendChild(buttonComputer);
                const buttonRandom = createButton("buttonRandom", "zufällig");
                questionStartPlayer.appendChild(buttonRandom);
                buttonRandom.style.margin = "20px 20px 462px 20px";
                let text = '';
                // Wenn einer der Buttons geklickt wird,
                // erscheint ein Text mit der Information wer das Spiel beginnt.
                // Mit der Spielvorbereitung wird fortgefahren
                // indem initializeGamePart2 aufgerufen wird.
                buttonHuman.addEventListener("click", function(event) {
                    text += "Du beginnst! Dein Symbol ist Kreuz.";
                    questionStartPlayer.innerHTML = text;
                    startPlayerComputer = false;
                    initializeGamePart2();
                });
                buttonComputer.addEventListener("click", function(event) {
                    text += "Der Computer beginnt! Dein Symbol ist Kreis.";
                    questionStartPlayer.innerHTML = text;
                    startPlayerComputer = true;
                    initializeGamePart2();
                });
                buttonRandom.addEventListener("click", function(event) {;
                    const random = Math.floor(Math.random()*2);
                    if (random == 0) {
                        text += "Du beginnst! Dein Symbol ist Kreuz.";
                        questionStartPlayer.innerHTML = text;
                        startPlayerComputer =  false;
                        initializeGamePart2();
                    }
                    else {
                        text += "Der Computer beginnt! Dein Symbol ist Kreis.";
                        questionStartPlayer.innerHTML = text;
                        startPlayerComputer =  true;
                        initializeGamePart2();
                    }
                });
            }

            function createButton(buttonName, value) {
                // Mit dieser Funktion wird ein Button erstellt.
                const button = document.createElement("input");
                button.id = buttonName;
                button.type = "button";
                button.value = value;
                return button;
            }


            function humanTurnOn() {
                // Fügt Event-Listener für das Klickereignis auf die Kacheln hinzu.
                for (let i = 0; i < 9; i++) {
                    const canvas = document.getElementById('myCanvas' + i);
                    canvas.addEventListener("click", humanTurn);
                }
            }

            function humanTurnOff() {
                // Entfernt Event-Listener für das Klickereignis auf die Kacheln.
                for (let i = 0; i < 9; i++) {
                    const canvas = document.getElementById('myCanvas' + i);
                    canvas.removeEventListener("click", humanTurn);
                }
            }

            function humanTurn(event) {
                // Der Spieler ist am Zug.
                // Das Spielbrett wird aktualisiert,
                // gegebenenfalls wird das Ende des Spiels ausgelöst,
                // der aktive Spieler wird gewechselt.

                // Bestimmt auf welches Feld geklickt wurde.
                const fieldName = event.target.id;
                const field = Number(fieldName.slice(-1));
                // Falls sich schon ein Symbol in der geklickten Kachel befindet,
                // passiert nichts.
                if (board.fields[field] == null) {
                    // Aktualisiert das Spielbrett.
                    changeOfBoard(field);
                    // Event Handler für das Klickereignis auf
                    // die Kacheln des Spielbretts wird entfernt.
                    humanTurnOff();
                    // Prüft, ob Bedingungen für das Spielende erfüllt sind.
                    const endOfGame = checkForEndOfGame();
                    // Gegebenenfalls wird das Ende des Spiels ausgelöst.
                    if (endOfGame[0] === true) {
                        // Eine Meldung zum Spielende wird ausgegeben.
                        // Gegebenenfalls wird das Spielbrett zurückgesetzt.
                        outputEndOfGame(endOfGame[1]);
                    }
                    // Der Computergegner ist nun an der Reihe.
                    if (startPlayerComputer === true) {
                        setTimeout(computerTurnCross, timeDelay);
                    }
                    else {
                        setTimeout(computerTurnCircle, timeDelay);
                    }
                }
            }

            function computerTurnCross() {
                // Das Symbol wird zu Kreuz gewechselt.
                isCircleTurn = false;
                // Prüft, ob sich schon zwei Kreuze in einer Reihe befinden.
                // Falls ja, wird ein drittes Kreuz gesetzt
                // und isActionNeeded wird auf true gesetzt.
                const isActionNeeded = checkForTwoInARowAndCompleteIt("cross");
                let isReactionNeeded = false;
                // Prüft, ob sich zwei Kreise in einer Reihe befinden.
                // Falls ja, wird ein Kreuz in die Reihe gesetzt
                // und isReactionNeeded wird auf true gesetzt.  
                if (isActionNeeded != true) {
                    isReactionNeeded = checkForTwoInARowAndCompleteIt("circle");
                }
                // Falls isActionNeeded und isReactionNeeded beide false sind,
                // versucht der Computer Kreuze so zu setzen, dass er gewinnen kann.
                if (isActionNeeded != true && isReactionNeeded != true) {
                    if (numberTurnKI == 1) {
                        changeOfBoard(0);
                        numberTurnKI++;
                    }
                    else if (numberTurnKI == 2 && board.fields[8] == null) {
                        changeOfBoard(8);
                        numberTurnKI++;
                    }
                    else if (numberTurnKI == 2 && board.fields[8] == 0) {
                        changeOfBoard(4);
                        numberTurnKI++;
                    }
                    else if (numberTurnKI == 3 && board.fields[8] == 1 && board.fields[2] == null && board.fields[1] == null && board.fields[5] == 0) {
                        changeOfBoard(2);
                        numberTurnKI++;
                    }
                    else if (numberTurnKI == 3 && board.fields[8] == 1 && board.fields[6] == null) {
                        changeOfBoard(6);
                        numberTurnKI++;
                    }
                    else if (numberTurnKI == 3 && board.fields[4] == 1 && board.fields[1] == null && board.fields[2] == null && board.fields[7] == null) {
                        changeOfBoard(1);
                        numberTurnKI++;
                    }
                    else if (numberTurnKI == 3 && board.fields[4] == 1 && board.fields[3] == null) {
                        changeOfBoard(3);
                        numberTurnKI++;
                    }
                    else {
                        for (let i = 0; i < 9; i++) {
                            if (board.fields[i] == null) {
                                changeOfBoard(i);
                                break;
                            }
                        }
                    }
                }
                // Prüft, ob Bedingungen für das Spielende erfüllt sind.
                const endOfGame = checkForEndOfGame();
                // Gegebenenfalls wird das Ende des Spiels ausgelöst.
                if (endOfGame[0] === true) {
                    isCircleTurn = null;
                    outputEndOfGame(endOfGame[1]);
                }
                // Ansonsten wird der aktive Spieler gewechselt.
                else {
                    isCircleTurn = true;
                    humanTurnOn();
                }
            }

            function computerTurnCircle() {
                // Das Symbol wird zu Kreis gewechselt.
                isCircleTurn = true;
                // Prüft, ob sich schon zwei Kreise in einer Reihe befinden.
                // Falls ja, wird ein dritter Kreis gesetzt
                // und isActionNeeded wird auf true gesetzt.
                const isActionNeeded = checkForTwoInARowAndCompleteIt("circle");
                let isReactionNeeded = false;
                // Prüft, ob sich zwei Kreuze in einer Reihe befinden.
                // Falls ja, wird ein Kreis in die Reihe gesetzt
                // und isReactionNeeded wird auf true gesetzt.  
                if (isActionNeeded != true) {
                    isReactionNeeded = checkForTwoInARowAndCompleteIt("cross");
                }
                // Falls isActionNeeded und isReactionNeeded beide false sind,
                // versucht der Computer Kreise so zu setzen, dass er gewinnen kann.
                if (isActionNeeded != true && isReactionNeeded != true) {
                    if (numberTurnKI == 1 && board.fields[4] == 1) {
                        changeOfBoard(0);
                        numberTurnKI++;
                    }
                    else if (numberTurnKI == 1) {
                        changeOfBoard(4);
                        numberTurnKI++;
                    }
                    else if (numberTurnKI == 2 && board.fields[0] == 0 && board.fields[8] == null) {
                        changeOfBoard(8);
                        numberTurnKI++;
                    }
                    else if (numberTurnKI == 2 && board.fields[0] == 0 && board.fields[6] == null) {
                        changeOfBoard(6);
                        numberTurnKI++;
                    }
                    else if (numberTurnKI == 2 && board.fields[0] == 0 && board.fields[2] == null) {
                        changeOfBoard(2);
                        numberTurnKI++;
                    }
                    else if (numberTurnKI == 2 && (board.fields[0] == 1 || board.fields[2] == 1) && board.fields[1] == null) {
                        changeOfBoard(1);
                        numberTurnKI++;
                    }
                    else if (numberTurnKI == 2 && (board.fields[6] == 1 || board.fields[8] == 1) & board.fields[7] == null) {
                        changeOfBoard(7);
                        numberTurnKI++;
                    }
                    else if (numberTurnKI == 3 && board.fields[6] == null) {
                        changeOfBoard(6);
                        numberTurnKI++;
                    }
                    else if (numberTurnKI == 3 && board.fields[2] == null) {
                        changeOfBoard(2);
                        numberTurnKI++;
                    }
                    else if (numberTurnKI == 3 && board.fields[8] == null) {
                        changeOfBoard(8);
                        numberTurnKI++;
                    }
                    else {
                        for (let i = 0; i < 9; i++) {
                            if (board.fields[i] == null) {
                                changeOfBoard(i);
                                break;
                            }
                        }
                    }
                }
                // Prüft, ob Bedingungen für das Spielende erfüllt sind.
                const endOfGame = checkForEndOfGame();
                // Gegebenenfalls wird das Ende des Spiels ausgelöst.
                if (endOfGame[0] === true) {
                    isCircleTurn = null;
                    outputEndOfGame(endOfGame[1]);
                }
                // Ansonsten wird der aktive Spieler gewechselt.
                else {
                    isCircleTurn = false;
                    humanTurnOn();
                }
            }

            function checkForTwoInARowAndCompleteIt (symbol) {
                // Es wird geprüft, ob sich zwei gleiche Symbole
                // in den Reihen, Spalten und Diagonalen befinden.
                // Sobald eine Reihe, Spalte oder Diagonale gefunden wurde,
                // auf die das zutrifft, wird das Symbol,
                // das an die Funktion übergeben wurde,
                // auf das noch leere Feld dieser Reihe, Spalte
                // oder Diagonale gesetzt und die Funktion wird beendet.
                // In diesem Fall wird true zurückgegeben.
                if (board.row1[symbol] == 2) {
                    if (board.fields[0] == null) {
                        changeOfBoard(0);
                        return true;
                    }
                    else if (board.fields[1] == null) {
                        changeOfBoard(1);
                        return true;
                    }
                    else if (board.fields[2] == null) {
                        changeOfBoard(2);
                        return true;
                    }
                }
                if (board.row2[symbol] == 2) {
                    if (board.fields[3] == null) {
                        changeOfBoard(3);
                        return true;
                    }
                    else if (board.fields[4] == null) {
                        changeOfBoard(4);
                        return true;
                    }
                    else if (board.fields[5] == null) {
                        changeOfBoard(5);
                        return true;
                    }
                }
                if (board.row3[symbol] == 2) {
                    if (board.fields[6] == null) {
                        changeOfBoard(6);
                        return true;
                    }
                    else if (board.fields[7] == null) {
                        changeOfBoard(7);
                        return true;
                    }
                    else if (board.fields[8] == null) {
                        changeOfBoard(8);
                        return true;
                    }
                }
                if (board.column1[symbol] == 2) {
                    if (board.fields[0] == null) {
                        changeOfBoard(0);
                        return true;
                    }
                    else if (board.fields[3] == null) {
                        changeOfBoard(3);
                        return true;
                    }
                    else if (board.fields[6] == null) {
                        changeOfBoard(6);
                        return true;
                    }
                }
                if (board.column2[symbol] == 2) {
                    if (board.fields[1] == null) {
                        changeOfBoard(1);
                        return true;
                    }
                    else if (board.fields[4] == null) {
                        changeOfBoard(4);
                        return true;
                    }
                    else if (board.fields[7] == null) {
                        changeOfBoard(7);
                        return true;
                    }
                }
                if (board.column3[symbol] == 2) {
                    if (board.fields[2] == null) {
                        changeOfBoard(2);
                        return true;
                    }
                    else if (board.fields[5] == null) {
                        changeOfBoard(5);
                        return true;
                    }
                    else if (board.fields[8] == null) {
                        changeOfBoard(8);
                        return true;
                    }
                }
                if (board.diagonal1[symbol] == 2) {
                    if (board.fields[0] == null) {
                        changeOfBoard(0);
                        return true;
                    }
                    else if (board.fields[4] == null) {
                        changeOfBoard(4);
                        return true;
                    }
                    else if (board.fields[8] == null) {
                        changeOfBoard(8);
                        return true;
                    }
                }
                if (board.diagonal2[symbol] == 2) {
                    if (board.fields[2] == null) {
                        changeOfBoard(2);
                        return true;
                    }
                    else if (board.fields[4] == null) {
                        changeOfBoard(4);
                        return true;
                    }
                    else if (board.fields[6] == null) {
                        changeOfBoard(6);
                        return true;
                    }
                }
            }

            function changeOfBoard(field) {
                // Zeichnet ein Kreuz oder einen Kreis.
                drawSymbol(field);
                // Aktualisiert das Objekt board.
                if (isCircleTurn === true) {
                    board.fields[field] = 0;
                    incrementLine(field, "circle");
                } else {
                    board.fields[field] = 1;
                    incrementLine(field, "cross");
                }
            }

            function drawSymbol(field) {
                // Zeichnet entweder ein Kreuz oder einen Kreis.
                const myCanvas = 'myCanvas' + field;
                const canvas = document.getElementById(myCanvas);
                const context = canvas.getContext('2d');
                context.strokeStyle = 'schwarz';
                context.lineWidth = 5;
                // Zeichnet einen Kreis
                if (isCircleTurn === true) {
                    context.moveTo(symbolPadding, widthTiles/2);
                    context.arc(widthTiles/2, widthTiles/2, (widthTiles-2*symbolPadding)/2, Math.PI, 3 * Math.PI);
                // Zeichnet ein Kreuz
                } else if (isCircleTurn === false) {
                    context.moveTo(symbolPadding, symbolPadding);
                    context.lineTo(widthTiles-symbolPadding, widthTiles-symbolPadding);
                    context.moveTo(symbolPadding, widthTiles-symbolPadding);
                    context.lineTo(widthTiles-symbolPadding, symbolPadding);
                }
                context.stroke();
            }

            function incrementLine(field, symbol) {
                // Aktualisiert den Wert für die Anzahl der Symbole
                // in den Reihen, Spalten und Diagonalen des Boards.
                if (field == 0) {
                    board.row1[symbol]++;
                    board.column1[symbol]++;
                    board.diagonal1[symbol]++;
                }
                if (field == 1) {
                    board.row1[symbol]++;
                    board.column2[symbol]++;
                }
                if (field == 2) {
                    board.row1[symbol]++;
                    board.column3[symbol]++;
                    board.diagonal2[symbol]++;
                }
                if (field == 3) {
                    board.row2[symbol]++;
                    board.column1[symbol]++;
                }
                if (field == 4) {
                    board.row2[symbol]++;
                    board.column2[symbol]++;
                    board.diagonal1[symbol]++;
                    board.diagonal2[symbol]++;
                }
                if (field == 5) {
                    board.row2[symbol]++;
                    board.column3[symbol]++;
                }
                if (field == 6) {
                    board.row3[symbol]++;
                    board.column1[symbol]++;
                    board.diagonal2[symbol]++;
                }
                if (field == 7) {
                    board.row3[symbol]++;
                    board.column2[symbol]++;

                }
                if (field == 8) {
                    board.row3[symbol]++;
                    board.column3[symbol]++;
                    board.diagonal1[symbol]++;
                }
            }


            function checkForEndOfGame() {
                // Prüft, ob einer der Spieler drei gleiche Symbole in einer Reihe setzen konnte
                // oder ob alle Felder Symbole enthalten ohne,
                // dass drei gleiche Symbole in einer Reiche zu finden sind.
                    let text = "";
                    let endOfGame = false;
                    // In dem Array winPatterns sind 8 Arrays gespeichert,
                    // die die Reihen, Spalten und Diagonalen des Spielbretts representieren.
                    const winPatterns = [
                        [0, 1, 2],
                        [3, 4, 5],
                        [6, 7, 8],
                        [0, 3, 6],
                        [1, 4, 7],
                        [2, 5, 8],
                        [0, 4, 8],
                        [2, 4, 6]
                    ];
                    // Gewinnbedingungen für Spieler 1 (Kreuz)
                    for (const pattern of winPatterns) {
                        const [a, b, c] = pattern;
                        if (board.fields[a] === 1 && board.fields[b] === 1 && board.fields[c] === 1) {
                            text = "Spieler 1 hat gewonnen!";
                            endOfGame = true;
                            break;
                        }
                    }
                    // Gewinnbedingungen für Spieler 2 (Kreis)
                    for (const pattern of winPatterns) {
                        const [a, b, c] = pattern;
                        if (board.fields[a] === 0 && board.fields[b] === 0 && board.fields[c] === 0) {
                            text = "Spieler 2 hat gewonnen!";
                            endOfGame = true;
                            break;
                        }
                    }
                    // Überprüfung auf ein Unentschieden
                    if (!endOfGame && !board.fields.includes(null)) {
                        text = "Das Spiel ist zu Ende. Keiner hat gewonnen.";
                        endOfGame = true;
                    }
                    // Gibt true zurück, falls das Spielende erreicht wurde;
                    // und dann auch einen entsprechenenden Text dazu,
                    // der in der Funktion outputEndOfGame ausgegeben wird.
                    // Sonst werden false und ein leerer String zurückgegeben.
                    return [endOfGame, text];
            }

            function outputEndOfGame(textEndOfGame) {
                // Erzeugt eine Textausgabe zum Spielende.
                document.getElementById("outputEnd").innerHTML = textEndOfGame;
                // Frage nach erneutem Spiel.
                document.getElementById("outputEnd").innerHTML 
                    += "<br>Willst du noch mal spielen?";
                document.getElementById("outputEnd").innerHTML 
                    += '&nbsp;&nbsp;<input value="Ja" onclick="resetGame()" type="button"></input>';
                document.getElementById("boardContainer").style.margin = "20px 20px 0px 20px";
            }

            function resetGame() {
                // setzt das Spiel zurück damit
                // es noch mal gespielt werden kann.
                removeCanvases();
                initializeGamePart1();
            }

            function removeCanvases() {
                // Entfernt die Kacheln und die Meldung zum Spielende.
                const outputStart = document.getElementById("outputStart");
                const questionStartPlayer = document.getElementById("questionStartPlayer");
                outputStart.removeChild(questionStartPlayer);
                const boardContainer = document.getElementById("boardContainer");
                document.getElementById("outputEnd").innerHTML = '';
                const br2 = document.getElementById("br2");
                boardContainer.removeChild(br2);
                const br5 = document.getElementById("br5");
                boardContainer.removeChild(br5); 
                for (let i = 0; i < 9; i++) {
                    const myCanvas = "myCanvas" + i;
                    const canvas = document.getElementById(myCanvas);
                    boardContainer.removeChild(canvas);
                }
            }

            initializeGamePart1();
        </script>
        <footer>
            <div class="footer-content">
                &copy; 2023 Tic Tac Toe. Alle Rechte vorbehalten.<br>
                <!-- <a href="Nutzungsbedingungen.html">Nutzungsbedingungen</a>
                <a href="Datenschutz.html">Datenschutzrichtlinien</a>
                <a href="Impressum.html">Impressum</a>-->
            </div>
        </footer>
    </body>
</html>